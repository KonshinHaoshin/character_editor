<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>游戏立绘展示工具</title>
    <style>
        /* --- 全局和基础样式 --- */
        
         :root {
            --primary-bg: #ffffff;
            --secondary-bg: #f7f7f7;
            --border-color: #e0e0e0;
            --text-color: #333333;
            --primary-accent: #007bff;
            --primary-accent-hover: #0056b3;
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --border-radius: 8px;
            --box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }
        
        body {
            font-family: var(--font-family);
            background-color: var(--primary-bg);
            color: var(--text-color);
            margin: 0;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            box-sizing: border-box;
        }
        /* --- 顶层布局 --- */
        
        .app-container {
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        /* --- 头部 --- */
        
        .app-header {
            text-align: center;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        .app-header h1 {
            margin: 0;
            font-size: 1.75rem;
            color: var(--text-color);
        }
        
        .app-header a {
            color: var(--primary-accent);
            text-decoration: none;
            font-size: 0.9rem;
        }
        
        .app-header a:hover {
            text-decoration: underline;
        }
        /* --- 主内容区 --- */
        
        .main-content {
            display: grid;
            grid-template-columns: 450px 1fr;
            /* 修改: 增加左侧面板宽度以容纳更多选项 */
            gap: 1.5rem;
            flex-grow: 1;
            align-items: flex-start;
            /* 顶部对齐 */
        }
        /* --- 控制面板 (左侧) --- */
        
        .controls-panel {
            background-color: var(--secondary-bg);
            border-radius: var(--border-radius);
            padding: 1rem;
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
            /* 移除: 取消max-height和overflow-y，让高度自适应内容，页面整体滚动 */
        }
        /* --- 预览区 (右侧) --- */
        
        .preview-panel {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 500px;
            /* 最小高度 */
            position: sticky;
            /* 修改: 粘滞定位 */
            top: 1rem;
            /* 修改: 距离顶部1rem处粘滞 */
        }
        
        .preview-wrapper {
            width: 100%;
            max-width: 500px;
            /* 预览框最大宽度 */
            aspect-ratio: 1 / 2;
            position: relative;
            margin: 0 auto;
            box-shadow: var(--box-shadow);
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
            overflow: hidden;
            background-color: #f0f2f5;
            background-image: linear-gradient(45deg, #e0e0e0 25%, transparent 25%), linear-gradient(-45deg, #e0e0e0 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #e0e0e0 75%), linear-gradient(-45deg, transparent 75%, #e0e0e0 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        
        .preview-wrapper .loading-spinner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid var(--primary-accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% {
                transform: translate(-50%, -50%) rotate(0deg);
            }
            100% {
                transform: translate(-50%, -50%) rotate(360deg);
            }
        }
        
        .preview-wrapper img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            pointer-events: none;
        }
        /* --- UI 组件 --- */
        
        .control-section {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .control-section h3 {
            margin: 0;
            font-size: 1.1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        .control-group {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        /* 按钮和选择框 */
        
        select,
        button {
            font-family: inherit;
            font-size: 1rem;
            padding: 0.6rem 0.8rem;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background-color: var(--primary-bg);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        select {
            width: 100%;
        }
        
        button:hover {
            border-color: var(--primary-accent);
            color: var(--primary-accent);
        }
        
        button.active {
            background-color: var(--primary-accent);
            color: white;
            border-color: var(--primary-accent);
        }
        
        button.layer-button {
            background-color: #e9e9e9;
            font-size: 0.85rem;
            padding: 0.4rem 0.6rem;
        }
        /* 新增: 清空按钮样式 */
        
        .clear-group-btn {
            font-size: 0.75rem;
            padding: 0.2rem 0.5rem;
            background-color: #f1f3f5;
            border-color: #dee2e6;
            color: #495057;
            font-weight: normal;
        }
        
        .clear-group-btn:hover {
            background-color: #e9ecef;
            border-color: #ced4da;
        }
        /* 当前姿势配置 */
        
        .composition-output {
            background-color: var(--primary-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            padding: 0.75rem;
            font-family: monospace;
            font-size: 0.8rem;
            word-break: break-all;
            min-height: 50px;
        }
        /* 差分选择框 */
        
        .layer-groups details {
            border-bottom: 1px solid var(--border-color);
            padding: 0.25rem 0;
        }
        
        .layer-groups details:last-child {
            border-bottom: none;
        }
        
        .layer-groups summary {
            cursor: pointer;
            font-weight: 500;
            padding: 0.5rem;
            border-radius: 4px;
            list-style: revert;
            /* 确保小三角可见 */
        }
        
        .layer-groups summary:hover {
            background-color: #e9e9e9;
        }
        
        .layer-groups .control-group {
            padding: 0.75rem;
        }
        /* 底部操作 */
        
        .actions-panel {
            display: flex;
            justify-content: center;
            gap: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-color);
        }
        
        .actions-panel button {
            min-width: 120px;
            font-weight: 500;
        }
        
        .actions-panel .export-btn {
            background-color: #28a745;
            color: white;
            border-color: #28a745;
        }
        
        .actions-panel .export-btn:hover {
            background-color: #218838;
            border-color: #1e7e34;
        }
        /* --- 响应式设计 --- */
        
        @media (max-width: 768px) {
            body {
                padding: 0.5rem;
            }
            .main-content {
                grid-template-columns: 1fr;
            }
            .controls-panel {
                order: 2;
                /* 在移动端将控制面板移到下方 */
            }
            .preview-panel {
                order: 1;
                position: static;
                /* 在移动端恢复默认定位 */
            }
            .preview-wrapper {
                max-width: 90vw;
                /* 移动端预览框最大宽度 */
            }
        }
    </style>
</head>

<body>

    <div class="app-container">
        <!-- 头部 -->
        <header class="app-header">
            <h1>雪莉的立绘展示工具</h1>
            <a href="https://manosabamoddoc.fuyumi.xyz/" target="_blank" rel="noopener noreferrer">我的主页</a>
        </header>

        <!-- 角色选择 -->
        <section class="control-section">
            <select id="character-selector" title="选择角色"></select>
        </section>

        <!-- 主内容区 -->
        <main class="main-content">
            <!-- 左侧控制面板 -->
            <aside class="controls-panel">
                <div class="control-section">
                    <h3>当前姿势配置</h3>
                    <div id="composition-output" class="composition-output"></div>
                </div>
                <!-- 操作按钮 -->
                <div class="control-section">
                    <h3>操作</h3>
                    <div class="control-group">
                        <button id="reset-button">一键重置</button>
                        <button id="export-button" class="export-btn">一键导出 (PNG)</button>
                    </div>
                </div>
                <div class="control-section">
                    <h3>姿势选择</h3>
                    <div id="composition-buttons" class="control-group"></div>
                </div>
                <div class="control-section">
                    <h3>差分细节调整</h3>
                    <div id="layer-groups" class="layer-groups"></div>
                </div>
            </aside>

            <!-- 右侧预览区 -->
            <section class="preview-panel">
                <div class="preview-wrapper" id="preview-wrapper">
                    <!-- 图片将动态插入此处 -->
                </div>
            </section>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM 元素引用 ---
            const characterSelector = document.getElementById('character-selector');
            const compositionButtonsContainer = document.getElementById('composition-buttons');
            const layerGroupsContainer = document.getElementById('layer-groups');
            const previewWrapper = document.getElementById('preview-wrapper');
            const compositionOutput = document.getElementById('composition-output');
            const resetButton = document.getElementById('reset-button');
            const exportButton = document.getElementById('export-button');

            // --- 角色列表 ---
            const characters = ['Alisa', 'AnAn', 'Coco', 'Ema', 'Hanna', 'Hiro', 'Leia', 'Margo', 'Meruru', 'Miria', 'Nanoka', 'Noah', 'Sherry'];

            // --- 全局状态 ---
            let currentCharacter = '';
            let layersInfo = []; // { group, name, order, path, id }
            let compositions = {}; // { name: [...parts] }
            let defaultComposition = {
                presets: [],
                layers: []
            };

            let activeCompositions = new Set();
            let manualLayerOverrides = {}; // { layerId: boolean }

            // --- 初始化 ---
            function init() {
                // 填充角色选择器
                characters.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    characterSelector.appendChild(option);
                });

                // 设置默认角色并加载
                characterSelector.value = 'Sherry';
                loadCharacter(characterSelector.value);

                // 绑定事件监听
                characterSelector.addEventListener('change', (e) => loadCharacter(e.target.value));
                resetButton.addEventListener('click', resetToDefault);
                exportButton.addEventListener('click', exportAsPNG);
            }

            // --- 数据加载与解析 ---
            async function loadCharacter(name) {
                currentCharacter = name;
                setLoading(true);
                resetState();

                try {
                    // 并行获取所有配置文件
                    const [infoText, compText, defaultCompText] = await Promise.all([
                        fetch(`./${name}/info.txt`).then(res => res.text()),
                        fetch(`./${name}/composition.txt`).then(res => res.text()),
                        fetch(`./${name}/default_composition.txt`).then(res => res.text())
                    ]);

                    // 解析数据
                    parseInfo(infoText);
                    parseCompositions(compText);
                    parseDefaultComposition(defaultCompText);

                    // 构建UI
                    buildCompositionButtons();
                    buildLayerControls();

                    // 应用默认状态并渲染
                    resetToDefault();
                } catch (error) {
                    console.error(`加载角色 ${name} 数据失败:`, error);
                    previewWrapper.innerHTML = `<p style="color:red; text-align:center; padding: 1rem;">加载角色'${name}'失败，请检查文件是否存在以及Web服务器是否正常运行。</p>`;
                } finally {
                    setLoading(false);
                }
            }

            function parseInfo(text) {
                layersInfo = text.trim().split('\n').map(line => {
                    const [group, name, order] = line.split(':');
                    if (!group || !name || !order) return null;
                    return {
                        group: group.trim(),
                        name: name.trim(),
                        order: parseInt(order, 10),
                        path: `./${currentCharacter}/${group}/${name}.png`,
                        id: `${group.trim()}/${name.trim()}`
                    };
                }).filter(Boolean).sort((a, b) => a.order - b.order);
            }

            function parseCompositions(text) {
                compositions = {};
                text.trim().split('\n').forEach(line => {
                    const [name, partsStr] = line.split(':', 2);
                    if (!name || !partsStr) return;
                    compositions[name.trim()] = partsStr.split(',').map(p => p.trim()).filter(Boolean);
                });
            }

            function parseDefaultComposition(text) {
                const [part1, part2] = text.trim().split(':', 2);

                const part1LayerStrings = [];
                const allPresetNames = [];

                if (part1) {
                    part1.split(',').map(p => p.trim()).forEach(item => {
                        if (!item) return;
                        // 使用 parseLayerString 来判断一个字符串是姿势名还是差分状态
                        const parsed = parseLayerString(item);
                        if (parsed.group) { // 如果能解析出 group，说明是差分状态
                            part1LayerStrings.push(item);
                        } else { // 否则认为是姿势名
                            allPresetNames.push(item);
                        }
                    });
                }

                const part2LayerStrings = part2 ? part2.split(',').map(p => p.trim()).filter(Boolean) : [];

                // 左边(part1)覆盖右边(part2)，所以应用时，part2的差分状态要先应用。
                // 在数组中，后面的项会覆盖前面的项，所以part1的差分状态要放在后面。
                defaultComposition.layers = [...part2LayerStrings, ...part1LayerStrings];
                defaultComposition.presets = allPresetNames;
            }

            // --- UI 构建 ---
            function buildCompositionButtons() {
                compositionButtonsContainer.innerHTML = '';
                Object.keys(compositions).sort().forEach(name => {
                    const button = document.createElement('button');
                    button.textContent = name;
                    button.dataset.name = name;
                    button.addEventListener('click', () => toggleComposition(name));
                    compositionButtonsContainer.appendChild(button);
                });
            }

            function buildLayerControls() {
                layerGroupsContainer.innerHTML = '';
                const groups = layersInfo.reduce((acc, layer) => {
                    if (!acc[layer.group]) {
                        acc[layer.group] = [];
                    }
                    acc[layer.group].push(layer);
                    return acc;
                }, {});

                Object.keys(groups).sort().forEach(groupName => {
                    const details = document.createElement('details');
                    const summary = document.createElement('summary');

                    // 创建一个容器来容纳标题和按钮，以便对齐
                    const summaryContent = document.createElement('div');
                    summaryContent.style.cssText = 'display: flex; justify-content: space-between; align-items: center; width: 100%;';

                    const summaryText = document.createElement('span');
                    summaryText.textContent = groupName;

                    const clearButton = document.createElement('button');
                    clearButton.textContent = '清空';
                    clearButton.className = 'clear-group-btn';
                    clearButton.addEventListener('click', (event) => {
                        event.stopPropagation(); // 阻止details元素的展开/折叠
                        clearGroupOverrides(groupName);
                    });

                    summaryContent.appendChild(summaryText);
                    summaryContent.appendChild(clearButton);
                    summary.appendChild(summaryContent);
                    details.appendChild(summary);

                    const buttonGroup = document.createElement('div');
                    buttonGroup.className = 'control-group';

                    groups[groupName].sort((a, b) => a.name.localeCompare(b.name)).forEach(layer => {
                        const button = document.createElement('button');
                        button.textContent = layer.name;
                        button.dataset.id = layer.id;
                        button.className = 'layer-button';
                        button.addEventListener('click', () => toggleLayer(layer.id));
                        buttonGroup.appendChild(button);
                    });
                    details.appendChild(buttonGroup);
                    layerGroupsContainer.appendChild(details);
                });
            }

            // --- 核心逻辑 ---
            function getAffectedGroupsFromComposition(compName) {
                const affectedGroups = new Set();
                const stack = [compName];
                const visited = new Set();

                while (stack.length > 0) {
                    const currentComp = stack.pop();
                    if (visited.has(currentComp)) continue;
                    visited.add(currentComp);

                    const parts = compositions[currentComp];
                    if (!parts) continue;

                    parts.forEach(part => {
                        if (compositions[part]) {
                            stack.push(part);
                        } else {
                            const {
                                group
                            } = parseLayerString(part);
                            if (group) {
                                affectedGroups.add(group);
                            }
                        }
                    });
                }
                return affectedGroups;
            }

            function toggleComposition(name) {
                const affectedGroups = getAffectedGroupsFromComposition(name);

                // 清除此姿势将影响的分组中的任何手动覆盖
                for (const layerId in manualLayerOverrides) {
                    const layer = layersInfo.find(l => l.id === layerId);
                    if (layer && affectedGroups.has(layer.group)) {
                        delete manualLayerOverrides[layerId];
                    }
                }

                if (activeCompositions.has(name)) {
                    activeCompositions.delete(name);
                } else {
                    activeCompositions.add(name);
                }

                updateStateAndRender();
            }

            function toggleLayer(layerId) {
                const currentStates = calculateLayerStates();
                const isCurrentlyOn = !!currentStates[layerId];
                manualLayerOverrides[layerId] = !isCurrentlyOn;
                updateStateAndRender();
            }

            // 修改: 清空特定分组的选择（手动关闭该组所有图层）
            function clearGroupOverrides(groupName) {
                const layersInGroup = layersInfo.filter(l => l.group === groupName);
                layersInGroup.forEach(layer => {
                    manualLayerOverrides[layer.id] = false;
                });
                updateStateAndRender();
            }

            // 新增: 统一处理差分表达式字符串的辅助函数
            function applyLayerStrings(layerStrings, states) {
                layerStrings.forEach(layerStr => {
                    const {
                        group,
                        name,
                        op
                    } = parseLayerString(layerStr);
                    if (!group) return;

                    if (op === '-' && !name) { // 处理 Group- 语法
                        layersInfo.filter(l => l.group === group).forEach(l => {
                            states[l.id] = false;
                        });
                        return;
                    }

                    const layerId = `${group}/${name}`;

                    if (op === '+') {
                        states[layerId] = true;
                    } else if (op === '-') {
                        states[layerId] = false;
                    } else if (op === '>') {
                        layersInfo.filter(l => l.group === group).forEach(l => {
                            states[l.id] = (l.name === name);
                        });
                    }
                });
            }

            function calculateLayerStates() {
                let states = {};

                // 1. 应用默认的【详细差分】状态
                applyLayerStrings(defaultComposition.layers, states);

                // 2. 应用所有当前激活的【姿势】
                applyCompositionRecursive(Array.from(activeCompositions), states);

                // 3. 应用用户【手动】的细节覆盖
                Object.assign(states, manualLayerOverrides);

                return states;
            }

            function applyCompositionRecursive(compNames, states) {
                compNames.forEach(compName => {
                    const parts = compositions[compName];
                    if (!parts) return;

                    parts.forEach(part => {
                        if (compositions[part]) {
                            applyCompositionRecursive([part], states);
                        } else {
                            // 在这里，我们直接使用 applyLayerStrings 来处理单个差分字符串
                            applyLayerStrings([part], states);
                        }
                    });
                });
            }

            function parseLayerString(layerStr) {
                const opMatch = layerStr.match(/[+\->]/);
                if (!opMatch) {
                    if (layerStr.endsWith('-')) {
                        const group = layerStr.slice(0, -1);
                        return {
                            group: group,
                            name: '',
                            op: '-'
                        };
                    }
                    return {};
                }

                const op = opMatch[0];
                const opIndex = opMatch.index;
                const group = layerStr.substring(0, opIndex);
                const name = layerStr.substring(opIndex + 1);
                return {
                    group,
                    name,
                    op
                };
            }

            function updateStateAndRender() {
                const finalStates = calculateLayerStates();
                renderPreview(finalStates);
                updateUI(finalStates);
                generateOptimizedExpression(finalStates);
            }

            // --- 渲染与UI更新 ---
            function renderPreview(states) {
                previewWrapper.innerHTML = '';
                layersInfo.forEach(layer => {
                    if (states[layer.id]) {
                        const img = new Image();
                        img.src = layer.path;
                        img.style.zIndex = layer.order;
                        img.onerror = () => {
                            img.src = `https://placehold.co/500x1000/f0f2f5/ccc?text=Image+Not+Found`;
                        };
                        previewWrapper.appendChild(img);
                    }
                });
            }

            function updateUI(states) {
                compositionButtonsContainer.querySelectorAll('button').forEach(btn => {
                    btn.classList.toggle('active', activeCompositions.has(btn.dataset.name));
                });

                layerGroupsContainer.querySelectorAll('button.layer-button').forEach(btn => {
                    btn.classList.toggle('active', !!states[btn.dataset.id]);
                });
            }

            function generateOptimizedExpression(finalStates) {
                const userPresetOrder = Array.from(activeCompositions);

                let presetOnlyStates = {};
                // 修正: 只根据当前激活的姿势计算基础状态，以正确进行对比
                applyLayerStrings(defaultComposition.layers, presetOnlyStates);
                applyCompositionRecursive(userPresetOrder, presetOnlyStates);

                const requiredOverrides = {};
                const overriddenGroups = new Set();
                const allLayerIds = new Set([...Object.keys(finalStates), ...Object.keys(presetOnlyStates)]);

                allLayerIds.forEach(layerId => {
                    const finalState = !!finalStates[layerId];
                    const presetState = !!presetOnlyStates[layerId];
                    if (finalState !== presetState) {
                        const layer = layersInfo.find(l => l.id === layerId);
                        if (layer) {
                            requiredOverrides[layer.id] = finalState;
                            overriddenGroups.add(layer.group);
                        }
                    }
                });

                const overrideExpressions = [];

                for (const groupName of overriddenGroups) {
                    const activeLayersInGroup = layersInfo.filter(l => l.group === groupName && finalStates[l.id]);

                    if (activeLayersInGroup.length === 0) {
                        overrideExpressions.push(`${groupName}-`);
                    } else if (activeLayersInGroup.length === 1) {
                        const activeLayer = activeLayersInGroup[0];
                        overrideExpressions.push(`${activeLayer.group}>${activeLayer.name}`);
                    } else {
                        layersInfo.forEach(layer => {
                            if (layer.group === groupName && requiredOverrides.hasOwnProperty(layer.id)) {
                                const op = requiredOverrides[layer.id] ? '+' : '-';
                                overrideExpressions.push(`${layer.group}${op}${layer.name}`);
                            }
                        });
                    }
                }

                let expression = userPresetOrder.join(',');
                if (overrideExpressions.length > 0) {
                    expression += (expression ? ',' : '') + overrideExpressions.sort().join(',');
                }

                compositionOutput.textContent = expression || 'Default';
            }

            // --- 辅助功能 ---
            function resetState() {
                activeCompositions.clear();
                manualLayerOverrides = {};
                layersInfo = [];
                compositions = {};
                defaultComposition = {
                    presets: [],
                    layers: []
                };
                compositionButtonsContainer.innerHTML = '加载中...';
                layerGroupsContainer.innerHTML = '';
            }

            function resetToDefault() {
                activeCompositions = new Set(defaultComposition.presets);
                manualLayerOverrides = {};
                updateStateAndRender();
            }

            async function exportAsPNG() {
                const finalStates = calculateLayerStates();
                const activeLayers = layersInfo.filter(l => finalStates[l.id]);

                if (activeLayers.length === 0) {
                    alert("没有可导出的内容。");
                    return;
                }

                setLoading(true, "正在导出...");

                try {
                    const loadedImages = await Promise.all(
                        activeLayers.map(layer => new Promise((resolve, reject) => {
                            const img = new Image();
                            img.crossOrigin = "anonymous";
                            img.onload = () => resolve({
                                img,
                                layer
                            });
                            img.onerror = reject;
                            img.src = layer.path;
                        }))
                    );

                    let maxWidth = 0;
                    let maxHeight = 0;
                    loadedImages.forEach(({
                        img
                    }) => {
                        if (img.naturalWidth > maxWidth) maxWidth = img.naturalWidth;
                        if (img.naturalHeight > maxHeight) maxHeight = img.naturalHeight;
                    });

                    if (maxWidth === 0 || maxHeight === 0) {
                        throw new Error("无法获取图片尺寸。");
                    }

                    const canvas = document.createElement('canvas');
                    canvas.width = maxWidth;
                    canvas.height = maxHeight;
                    const ctx = canvas.getContext('2d');

                    loadedImages.forEach(({
                        img
                    }) => {
                        ctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight);
                    });

                    const link = document.createElement('a');
                    link.download = `${currentCharacter}_export_${Date.now()}.png`;
                    link.href = canvas.toDataURL('image/png');
                    link.click();

                } catch (error) {
                    console.error("导出失败:", error);
                    alert("导出图片失败。请检查控制台获取更多信息。\n这可能是由于浏览器安全策略（CORS）导致的，请确保在Web服务器环境下运行。");
                } finally {
                    setLoading(false);
                }
            }

            function setLoading(isLoading, text = '') {
                if (isLoading) {
                    const spinner = document.createElement('div');
                    spinner.className = 'loading-spinner';
                    previewWrapper.innerHTML = '';
                    previewWrapper.appendChild(spinner);
                    if (text) {
                        const label = document.createElement('p');
                        label.textContent = text;
                        label.style.textAlign = 'center';
                        label.style.marginTop = '70px';
                        spinner.appendChild(label);
                    }
                } else {
                    const spinner = previewWrapper.querySelector('.loading-spinner');
                    if (spinner) {
                        spinner.remove();
                    }
                }
            }

            // --- 启动应用 ---
            init();
        });
    </script>
</body>

</html>